<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="C++Primer5 第6章 函数" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="说明：本章讲述函数的定义和声明、函数传参、返回类型、重载函数、函数匹配以及函数指针。" /><meta property="og:description" content="说明：本章讲述函数的定义和声明、函数传参、返回类型、重载函数、函数匹配以及函数指针。" /><link rel="canonical" href="https://shenshenzhou.github.io/posts/C++Primer6/" /><meta property="og:url" content="https://shenshenzhou.github.io/posts/C++Primer6/" /><meta property="og:site_name" content="ShenshenZhou" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-01-03T22:13:44+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++Primer5 第6章 函数" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="EbIRAK-yj0lEMVk1uQwtW66urJnY8yfKtT112zfnTfA" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-07-01T12:21:39+08:00","datePublished":"2022-01-03T22:13:44+08:00","description":"说明：本章讲述函数的定义和声明、函数传参、返回类型、重载函数、函数匹配以及函数指针。","headline":"C++Primer5 第6章 函数","mainEntityOfPage":{"@type":"WebPage","@id":"https://shenshenzhou.github.io/posts/C++Primer6/"},"url":"https://shenshenzhou.github.io/posts/C++Primer6/"}</script><title>C++Primer5 第6章 函数 | ShenshenZhou</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="ShenshenZhou"><meta name="application-name" content="ShenshenZhou"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://fastly.jsdelivr.net"><link rel="dns-prefetch" href="https://fastly.jsdelivr.net"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://fastly.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/images/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">ShenshenZhou</a></div><div class="site-subtitle font-italic">好好学习 天天向上</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/ShenshenZhou" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['15797870468','163.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-5" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>C++Primer5 第6章 函数</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++Primer5 第6章 函数</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> ShenshenZhou </span> 发表于 <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="2022-01-03, 22:13 +0800" >2022-01-03<i class="unloaded">2022-01-03T22:13:44+08:00</i> </span></div><div> <span> 更新于 <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="2022-07-01, 12:21 +0800" >2022-07-01<i class="unloaded">2022-07-01T12:21:39+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4929 字">27 分钟 阅读</span></div></div><div class="post-content"><p><strong>说明：</strong>本章讲述函数的定义和声明、函数传参、返回类型、重载函数、函数匹配以及函数指针。</p><h3 id="函数基础">函数基础</h3><p>1、函数的定义包括一下部分：返回类型、函数名字、0个或多个形参组成的列表或函数体。</p><p>2、函数的调用完成两项工作：一是实参初始化函数对应的形参；二是将控制权转移给被调用函数，此时，主调函数的执行被暂时中断，被调函数开始执行。</p><p>3、遇到return语句时函数结束执行过程。也是完成两项工作，一是返回return语句中的值，如果有的话；二是将控制权从被调函数移回主调函数。</p><p>4、实参的类型必须和形参类型一致（但是可以执行隐式类型转换），就想初始值的类型必须和初始化对象的类型匹配一样。</p><p>5、函数的形参列表可以为空，但不能省略，形参用逗号分隔，每个形参都是含有一个声明符的声明，即时两个形参的类型一样，也必须把两个类型都写出来。</p><p>6、在C++中，名字有作用域，对象有生存周期。形参和函数体内定义的变量为局部变量，局部变量仅在函数的作用域可见，同时还会隐藏外层作用域中同名的其他所有声明。在所有函数体之外定义的对象在程序启动时被创建，直到程序结束时才会销毁。</p><p>7、有些时候，有必要令全局变量的生命周期贯穿在函数调用及之后的时间，可以定义为<code class="language-plaintext highlighter-rouge">static</code>类型。局部静态变量在程序执行路径第一次经过对象定义语句时初始化，直到程序终止才被销毁，在此期间对象所在的函数结束执行也不会对它有影响。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">count_calls</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">static</span> <span class="kt">int</span> <span class="n">ctr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">++</span><span class="n">ctr</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// 如果不是static类型 输出全是1 因为每次调用函数都会初始化变量ctr</span>
		<span class="c1">// statci类型的话 再次调用函数时 ctr已经存在了 并且是前一次函数返回的值 </span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">count_calls</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>8、与变量类似，函数应该在头文件中声明而在源文件中定义。这样可以确保同一函数的所有声明保持一致，而且想要改变函数借口，只需改变一条声明语句即可。</p><h3 id="参数传递">参数传递</h3><p>和其他变量一样，形参的类型决定了形参和实参的交互方式。如果形参是引用类型，它将绑定到对应的实参上，否则，将实参的值拷贝后赋给形参，即引用传递和值传递。</p><h4 id="值传递">值传递</h4><p>初始值会拷贝给一个变量，对变量的改动不会影响初始值。</p><h4 id="引用传递">引用传递</h4><p>尽量使用引用传递，如果无需改变引用形参的值，最好将其声明为常量引用。</p><h4 id="const形参和实参">const形参和实参</h4><p>当用实参初始化形参时会忽略掉顶层const，换句话说：当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。</p><p>我们可以使用非常量初始化一个底层const对象，但是反过来不行。</p><p>把函数不会改变的形参定义为普通引用是一个比较常见的错误：</p><ul><li>误导调用者，使人感觉函数可以修改它的实参的值。<li>非常量引用会极大的限制函数所能接受的实参类型，如上所述，我们不能用const对象、字面值或者需要类型转换的对象传递给普通的引用形参。<li>还有一个难以察觉的问题，假设其它参数将他们的形参定义为常量引用，那么上述find_char就无法在此类函数中正常使用。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// 上述第二点</span>
<span class="kt">int</span> <span class="nf">find_char</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">occurs</span><span class="p">);</span>  <span class="c1">// 不良设计 应为const string&amp;</span>
<span class="n">find_char</span><span class="p">(</span><span class="s">"Hello world"</span><span class="p">,</span> <span class="sc">'o'</span><span class="p">,</span> <span class="n">ctr</span><span class="p">);</span>  <span class="c1">// 错误 字面值常量不能传给普通引用变量</span>

<span class="c1">// 上述第三点</span>
<span class="kt">bool</span> <span class="nf">is_sentence</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">ctr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// 下面错误 因为s是常量引用 而find_char被定义为只接受普通引用</span>
    <span class="k">return</span> <span class="n">find_char</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="sc">'.'</span><span class="p">,</span> <span class="n">ctr</span><span class="p">)</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">ctr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>  
<span class="p">}</span>
</pre></table></code></div></div><p><strong>所以要尽量使用常量引用</strong></p><h4 id="数组形参">数组形参</h4><p>1、尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式，如果我们给print函数传递一个数组，实参自动的转换为指向数组首元素的指针，数组的大小对函数的调用没有影响。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="p">);</span>  <span class="c1">// 三种方式一样 形参都是int*类型</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">[]);</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>
</pre></table></code></div></div><p>2、C++允许将变量定义为数组的引用，类似的，形参也可以是数组的引用。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">)[</span><span class="mi">10</span><span class="p">]){</span>  <span class="c1">// 必须带括号 数组从数组名由内像外阅读</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">elem</span> <span class="o">:</span> <span class="n">arr</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">elem</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="含有可变形参的函数">含有可变形参的函数</h4><p>有时我们无法提前预知应该向函数传递几个实参。为了编写处理不同数量实参的函数，<strong>C++11</strong>提供了两种方法：如果所有的实参类型相同，可以传递一个名为<code class="language-plaintext highlighter-rouge">initializer_list</code>的标准库类型；如果实参的类型不同，可以编写一种特殊的函数，也就是可变参数模板（16.4节）。</p><p><code class="language-plaintext highlighter-rouge">initializer_list</code>：函数实参数量未知但全部实参类型相同，是标准库类型，定义在同名头文件中。</p><p>与vector一样，initializer_list是一种模板类，但是其对象中的元素永远是常量值，我们无法改变。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">error_msg</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">i1</span><span class="p">){</span>
    <span class="c1">// 有begin和end成员 可以范围for语句处理 </span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">beg</span> <span class="o">=</span> <span class="n">i1</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">beg</span> <span class="o">!=</span> <span class="n">i1</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">beg</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">beg</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>如果想向initializer_list形参中传递一个值的序列，必须把序列放在一对花括号内。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// 下面是两个string对象 第一次调用传入三个值 第二次传入两个值</span>
<span class="k">if</span> <span class="p">(</span><span class="n">expected</span> <span class="o">!=</span> <span class="n">actual</span><span class="p">)</span>
    <span class="n">error_msg</span><span class="p">({</span> <span class="s">"functionX"</span><span class="p">,</span> <span class="n">expected</span><span class="p">,</span> <span class="n">actual</span> <span class="p">});</span>
<span class="k">else</span>
    <span class="nf">error_msg</span><span class="p">({</span> <span class="s">"functionX"</span><span class="p">,</span> <span class="s">"ok"</span> <span class="p">});</span>
</pre></table></code></div></div><p>省略符形参：为了便于让C++程序访问某些特殊的C代码设置的，应该仅仅用于C和C++通用的类型，应该注意的是：大多数类类型的对象在传递给省略符形参时都无法正确拷贝。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">parm_list</span><span class="p">,</span> <span class="p">...);</span>  <span class="c1">// 对应于部分指定形参的实参是执行类型检查</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(...);</span>  <span class="c1">// 省略符形参所对应的实参无需类型检查。</span>
</pre></table></code></div></div><h3 id="返回类型和return语句">返回类型和return语句</h3><p>return语句终止当前正在执行的函数并将控制权返回到调动该函数的地方。</p><h4 id="无返回值函数">无返回值函数</h4><p>1、返回void的函数不要求非得有return语句，因为在这类函数最后一句后面会隐式地执行return。</p><p>2、void函数如果想在中间位置提前退出，可以使用return语句。</p><p>3、返回值为void的函数可以使用return expression的形式，但是该语句必须是另一个返回void的函数，强行返回其它类型的表达式会产生错误。</p><h4 id="有返回值函数">有返回值函数</h4><p>1、只要函数的返回类型不是void，则该函数内的每条return语句必须返回一个值。return语句的返回值的类型必须与函数的返回类型相同，或者能隐式的转换成函数返回类型。</p><p>2、在含有return语句的循环后面，应该也有一天return语句，如果没有的话程序会出错！！！</p><p>3、返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。</p><p>4、如果函数返回引用，则该引用仅是它所引对象的一个别名。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// 无论是调用函数还是返回结果都不会真正拷贝string对象 而只是它的一个别名</span>
<span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">shorterString</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s2</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">s2</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>5、<strong>不要返回局部对象的引用或指针</strong></p><blockquote><p>函数完成后，它所占用的存储空间也随之被释放掉，因此，返回一个局部对象的引用或指针，会使引用和指针指向一个不存在的对象！</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">manip</span><span class="p">(){</span>
	<span class="n">string</span> <span class="n">ret</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>  <span class="c1">// 错误 返回局部对象的引用</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="s">"empty"</span><span class="p">;</span>  <span class="c1">// 错误 返回一个局部临时量</span>
<span class="p">}</span>
</pre></table></code></div></div><p>6、调用运算符的优先级与点运算符和箭头运算符相同，并且符合左结合率。因此，如果函数返回指针、引用、类的对象，我们能使用函数调用的结果访问结果对象的成员。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">sz</span><span class="o">=</span><span class="n">shorterString</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">).</span><span class="n">size</span><span class="p">();</span>  <span class="c1">// 返回对象是string 所以可以调用size()</span>
</pre></table></code></div></div><p>7、调用一个返回引用的函数得到左值，其它返回类型得到右值。可以像使用其它左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是<strong>非常量引用</strong>的函数的结果幅值。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">char</span><span class="o">&amp;</span> <span class="n">getVal</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ix</span><span class="p">){</span>
	<span class="k">return</span> <span class="n">str</span><span class="p">[</span><span class="n">ix</span><span class="p">];</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
	<span class="n">string</span> <span class="n">s</span><span class="p">{</span><span class="s">"a value"</span><span class="p">};</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">getVal</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="sc">'A'</span><span class="p">;</span>  <span class="c1">// 将s[0]的值改为A</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>8、函数可以返回花括号包围的值。<strong>C++11</strong></p><blockquote><p>类似于其它返回结果，可以用用此列表来初始化表示函数返回的临时对象。</p><p>如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间。如果函数返回的是类类型，由类本身定义初始值如何使用。</p></blockquote><h4 id="返回数组指针">返回数组指针</h4><p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。</p><p>1、使用类型别名</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>  <span class="c1">// arr是一个类型别名 表示的类型为含有十个整数的数字</span>
<span class="k">using</span> <span class="n">arr</span> <span class="o">=</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>  <span class="c1">// 同上 C++11</span>
<span class="n">arr</span><span class="o">*</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>  <span class="c1">// func返回一个指向arr数组的指针</span>
</pre></table></code></div></div><p>2、声明一个返回数组指针的函数</p><p>数组的维度必须跟在函数名字后面，且形参列表应该由于数组的维度。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">))[</span><span class="mi">10</span><span class="p">];</span>  <span class="c1">// func返回一个指针 指针指向整型数组 必须带小括号</span>
</pre></table></code></div></div><p>3、使用尾置返回类型 <strong>C++11</strong></p><p>尾置返回类型跟在形参列表后面并以一个-&gt;符号开头，为了表示真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">10</span><span class="p">];</span>  <span class="c1">// 返回一个指针 该指针指向整型数组</span>
</pre></table></code></div></div><p>4、会用decltype</p><p>如果我们已经知道函数返回的指针将指向哪个数组，就可以使用decltype声明返回类型。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">odd</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span> <span class="p">};</span>
<span class="kt">int</span> <span class="n">even</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span> <span class="p">};</span>
<span class="k">decltype</span><span class="p">(</span><span class="n">odd</span><span class="p">)</span> <span class="o">*</span><span class="n">arrptr</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">odd</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">even</span><span class="p">;</span>  <span class="c1">// 返回一个指向数组的指针 既然是指针 别忘了&amp;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="函数重载">函数重载</h3><p>1、函数名字相同且形参列表不同，称为函数重载。函数名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻起名字、记名字的负担。</p><p>2、重载函数应该在形参数量或形参类型上有所不同。</p><p>3、重载和const形参</p><ul><li>顶层const不影响函数的对象，一个有顶层const的形参无法和另一个没有顶层const的形参区分。<li>如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的从const是底层的。因为底层const不能转换为其它类型，只能将const对象传递给const形参。虽然非常量可以转换为const，但是编译器会优先选用非常量版本的函数，所以可以区分。</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">Record</span> <span class="nf">lookup</span><span class="p">(</span><span class="n">phone</span><span class="p">);</span>
<span class="n">Record</span> <span class="nf">lookup</span><span class="p">(</span><span class="k">const</span> <span class="n">phone</span><span class="p">);</span>  <span class="c1">// 重复声明函数 形参类型并不能区分</span>
<span class="n">Record</span> <span class="nf">lookup</span><span class="p">(</span><span class="n">Account</span><span class="o">&amp;</span><span class="p">);</span>  <span class="c1">// 函数作用于引用</span>
<span class="n">Record</span> <span class="nf">lookup</span><span class="p">(</span><span class="k">const</span> <span class="n">Account</span><span class="o">&amp;</span><span class="p">);</span>  <span class="c1">// 函数作用于常量引用 底层const</span>
</pre></table></code></div></div><p>4、函数匹配是一个过程，在这个过程中可以把函数调用与一组重载函数的某个函数关联起来。</p><p>5、调用函数重载时有三种可能的结果</p><ul><li>编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。<li>找不到任何一个函数与调用的实参匹配，发出无匹配的错误信息。<li>有多于一个函数可以匹配，但是每一个都不是明显的最佳选择，将发生错误。称为二义性调用。</ul><p>6、通常来说，不应该在局部作用域内声明函数，因为在内层作用域内声明名字，它将隐藏外层作用域中声明的同名实体（同名变量也可以隐藏函数），在不同作用域中无法重载函数名。</p><blockquote><p>C++中，名字查找发生在类型检查之间。也就是说一旦名字发生重复，内层将隐藏外层。</p></blockquote><h3 id="特殊用途语言特性">特殊用途语言特性</h3><h4 id="默认实参">默认实参</h4><p>1、可以为形参提供默认实参，但是一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p><p>2、函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">string</span> <span class="nf">screen</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">hz</span> <span class="o">=</span> <span class="mi">24</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">wid</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="kt">char</span> <span class="n">backgrnd</span> <span class="o">=</span> <span class="sc">' '</span><span class="p">);</span>  <span class="c1">// 函数声明</span>
<span class="n">string</span> <span class="n">window</span><span class="p">;</span>
<span class="n">window</span> <span class="o">=</span> <span class="n">screen</span><span class="p">();</span>  <span class="c1">// 等于调用screen(24,80,' ')</span>
<span class="n">window</span> <span class="o">=</span> <span class="n">screen</span><span class="p">(</span><span class="mi">66</span><span class="p">);</span>  <span class="c1">// 等于调动screen(66,80,' ')</span>
<span class="n">window</span> <span class="o">=</span> <span class="n">screen</span><span class="p">(</span><span class="mi">66</span><span class="p">,</span><span class="mi">256</span><span class="p">);</span>  <span class="c1">// 等于调用screen(66,256,' ') </span>
</pre></table></code></div></div><p>3、函数可以多次声明，但是在给定的作用域内，一个形参只能被赋予一次默认实参。</p><p>4、局部变量不能作为默认实参。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">size_t</span> <span class="n">wd</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">def</span> <span class="o">=</span> <span class="sc">' '</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="nf">ht</span><span class="p">();</span>
<span class="n">string</span> <span class="nf">screen</span><span class="p">(</span><span class="kt">size_t</span> <span class="o">=</span> <span class="n">ht</span><span class="p">(),</span> <span class="kt">size_t</span> <span class="o">=</span> <span class="n">wd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">=</span> <span class="n">def</span><span class="p">);</span>
<span class="n">string</span> <span class="n">window</span> <span class="o">=</span> <span class="n">screen</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">f2</span><span class="p">(){</span>
    <span class="n">def</span> <span class="o">=</span> <span class="sc">'*'</span><span class="p">;</span>  <span class="c1">// 改变默认实参的值</span>
    <span class="kt">size_t</span> <span class="n">wd</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>  <span class="c1">// 隐藏了外层定义的wd 但是没有改变默认值</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">screen</span><span class="p">();</span>  <span class="c1">// 相当于调用screen(ht(), 80, '*')</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="内联函数">内联函数</h4><p>将函数指定为内联函数，通常就是将它在每个调用点处内联的展开。可以减少函数运行时的开销。</p><blockquote><p>内联只是向编译器的一个请求，编译器可以选择忽略，就是内联不内联，编译器说的算。</p></blockquote><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">shorterString</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">?</span> <span class="n">s1</span> <span class="o">:</span> <span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>  <span class="c1">// 调用处内联展开</span>
</pre></table></code></div></div><h4 id="constexpr函数">constexpr函数</h4><p>1、字面值属于常量表达式，用字面值初始化的const对象也是常量表达式(非const对象不是)。</p><p>2、constexptr函数的返回类型及所有形参的类型都得是字面值类型，而且函数体重必须有且只有一条return语句，但是它并一定返回查常量表达式。</p><h3 id="函数匹配">函数匹配</h3><p>1、确定候选函数</p><ul><li>候选函数与被调用的函数同名<li>候选函数声明在函数调用点可见</ul><p>2、从候选函数中选出可行函数</p><ul><li>可行函数形参数量与本次调用提供的实参数量相等<li>每个实参的类型与对应的形参类型相同，或者能转换成形参的类型</ul><p>3、寻找最佳匹配</p><p>逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。</p><p>有且只有一个函数满足以下条件，则匹配成功：</p><ul><li>该函数每个实参的匹配都不劣于其它可行函数需要的匹配<li>至少有一个实参的匹配由于其它可行函数提供的匹配</ul><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">double</span> <span class="kt">double</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="mf">2.56</span><span class="p">);</span>  <span class="c1">// 二义性调用 报错</span>
</pre></table></code></div></div><h3 id="函数指针">函数指针</h3><p>1、函数指针指向的是函数而非对象，和其他指针一样，函数指针指向某种特定类型，函数的类型由它的形参类型和返回类型共同决定，与函数名无关。声明一个指向该函数的指针，只需要用指针替换函数名即可，注意指针加上()！</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">lengthCompare</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="kt">bool</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">);</span>  <span class="c1">// 上述函数类型</span>
<span class="n">vool</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">);</span>  <span class="c1">// pf指向一个函数</span>
</pre></table></code></div></div><p>2、当我们把函数名作为一个值使用时，该函数自动地转换成指针。还能使用指向函数的指针调用该函数，无需提前解引用指针。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">pf</span> <span class="o">=</span> <span class="n">lengthCompare</span><span class="p">();</span>  <span class="c1">// pf指向该函数</span>
<span class="n">pf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lengthCompare</span><span class="p">();</span>  <span class="c1">// 等价</span>
<span class="kt">bool</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">pf</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"goodbye"</span><span class="p">);</span>  <span class="c1">// 调用函数</span>
<span class="kt">bool</span> <span class="n">b2</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="s">"hello"</span><span class="p">,</span> <span class="s">"goodbye"</span><span class="p">);</span>  <span class="c1">// 等价调用</span>
</pre></table></code></div></div><p>3、指向不同函数类型的指针间不存在转换规则（即类型不能隐式转换，需要精确匹配），但是我们可以为函数指针赋一个nullptr或者值为0的整型常量表达式。</p><p>4、形参可以是指向函数的指针，此时形参看起来是函数类型，实际上却是当成指针使用，我们可以直接把函数当做实参使用，此时它会自动转换为指针。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="nf">useBigger</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s2m</span><span class="p">,</span> <span class="kt">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">));</span>  <span class="c1">// 将形参定义成指向函数的指针</span>
<span class="n">useBigger</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">lengthCompare</span><span class="p">);</span> <span class="c1">// 自动将函数转换为指向该函数的指针</span>
</pre></table></code></div></div><p>5、和数组一样，decltype返回函数类型，不会将函数类型自动转换成指针类型。</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span text-data=" C++ "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">decltype</span><span class="p">(</span><span class="n">sumLength</span><span class="p">)</span> <span class="o">*</span><span class="n">getFcn</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="p">);</span> <span class="c1">// 牢记加上指针！！！</span>
</pre></table></code></div></div><p>6、和数组类似，虽然不能返回一个函数，但是可以返回一个指向函数的指针，最好使用类型别名。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%AC%94%E8%AE%B0/'>笔记</a>, <a href='/categories/c/'>C++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/%E7%AC%94%E8%AE%B0/" class="post-tag no-text-decoration" >笔记</a> <a href="/tags/c-primer5/" class="post-tag no-text-decoration" >C++Primer5</a> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++Primer5 第6章 函数 - ShenshenZhou&url=https://shenshenzhou.github.io/posts/C++Primer6/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++Primer5 第6章 函数 - ShenshenZhou&u=https://shenshenzhou.github.io/posts/C++Primer6/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++Primer5 第6章 函数 - ShenshenZhou&url=https://shenshenzhou.github.io/posts/C++Primer6/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>最近更新</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/webserver-webbench/">Webserver压力测试</a><li><a href="/posts/Sort/">C++实现十大排序算法</a><li><a href="/posts/Redis-knowledge/">Redis相关知识整理</a><li><a href="/posts/MySQL-knowledge/">MySQL相关知识整理</a><li><a href="/posts/leetcode200/">LeetCode200题记录</a></ul></div><div id="access-tags"> <span>热门标签</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a> <a class="post-tag" href="/tags/%E6%80%BB%E7%BB%93/">总结</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/c-primer5/">C++Primer5</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag" href="/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/">蓝桥杯</a> <a class="post-tag" href="/tags/%E9%A2%98%E8%A7%A3/">题解</a> <a class="post-tag" href="/tags/%E5%85%AB%E8%82%A1/">八股</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/%E7%BD%91%E9%A1%B5%E8%B5%84%E6%96%99/">网页资料</a></div></div></div><script src="https://fastly.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">文章内容</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/C++Primer1/"><div class="card-body"> <span class="timeago small" >2021-12-07<i class="unloaded">2021-12-07T23:14:26+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++Primer5 第1章 开始</h3><div class="text-muted small"><p> 说明：第一章介绍C++的大部分基础内容，看完后可以编写运行一个简单的程序，所以这部分笔记主要记述一些重要的点(note部分)。 类型： 一种类型不仅定义了数据的内容，还定义了这类数据上可以进行的运算。 编译器： 编译器没有能力检查一个程序是否按照你的意愿运行，但可以检查形式上的错误，比如syntax error、type error、declaration error。...</p></div></div></a></div><div class="card"> <a href="/posts/C++Primer2/"><div class="card-body"> <span class="timeago small" >2021-12-12<i class="unloaded">2021-12-12T15:14:26+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++Primer5 第2章 变量和基本类型</h3><div class="text-muted small"><p> 说明：本章主要介绍基本内置数据类型。 基本内置类型 算数类型：整型、浮点型、字符型、布尔 空类型：void 算数类型 1、算数类型的大小在不同机器上有所差别，C++规定了最小值。 char：8位，C++32、64位机器均为1个字节。 int：16位，C++32、64位机器均为4个字节。 long long ：64位，C++32、64位机器均为8个字节。 ...</p></div></div></a></div><div class="card"> <a href="/posts/C++Primer3/"><div class="card-body"> <span class="timeago small" >2021-12-18<i class="unloaded">2021-12-18T21:42:04+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++Primer5 第3章 字符串、向量和数组</h3><div class="text-muted small"><p> 说明：本章主要介绍数组以及两种标准库容器string和vector。 命名空间的using声明 1、作用域操作符::含义：编译器从操作符左侧名字所示的作用域中寻找右侧那个名字。 2、头文件不应该包含using声明，因为头文件的内容会拷贝到所有引用它的文件中去，可能会引发名字冲突。 标准库类型string string表示可变长的字符序列，使用string类型必须包含string头文件...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/C++Primer5/" class="btn btn-outline-primary" prompt="上一篇"><p>C++Primer5 第5章 语句</p></a> <a href="/posts/C++Primer7/" class="btn btn-outline-primary" prompt="下一篇"><p>C++Primer5 第7章 类</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/ShenshenZhou">ShenshenZhou</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">热门标签</h4><a class="post-tag" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a> <a class="post-tag" href="/tags/%E6%80%BB%E7%BB%93/">总结</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/c-primer5/">C++Primer5</a> <a class="post-tag" href="/tags/%E7%AE%97%E6%B3%95/">算法</a> <a class="post-tag" href="/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/">蓝桥杯</a> <a class="post-tag" href="/tags/%E9%A2%98%E8%A7%A3/">题解</a> <a class="post-tag" href="/tags/%E5%85%AB%E8%82%A1/">八股</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/%E7%BD%91%E9%A1%B5%E8%B5%84%E6%96%99/">网页资料</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://fastly.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://fastly.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://fastly.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
