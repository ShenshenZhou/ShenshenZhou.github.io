<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://shenshenzhou.github.io/</id><title>ShenshenZhou</title><subtitle>这里是 ShenshenZhou 的博客，用来记录技术上的成长与思考。</subtitle> <updated>2024-06-04T14:59:49+08:00</updated> <author> <name>ShenshenZhou</name> <uri>https://shenshenzhou.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://shenshenzhou.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://shenshenzhou.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2024 ShenshenZhou </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Webserver压力测试</title><link href="https://shenshenzhou.github.io/posts/webserver-webbench/" rel="alternate" type="text/html" title="Webserver压力测试" /><published>2022-07-26T09:28:30+08:00</published> <updated>2022-08-07T21:34:44+08:00</updated> <id>https://shenshenzhou.github.io/posts/webserver-webbench/</id> <content src="https://shenshenzhou.github.io/posts/webserver-webbench/" /> <author> <name>ShenshenZhou</name> </author> <category term="项目" /> <category term="MyWebServer" /> <summary> webbench压力测试 ==webbench简介== webbench是Linux下使用的一个轻量级（适用于中小型网站）的服务器压力测试工具，通过webbench可以得到以下数据： Speed传输速度，每分钟请求数及每秒请求字节数 Requests请求数量，统计成功和失败次数 ==测试原理== 利用fork建立多个子进程，每个子进程在测试时间内不断发送请求报文，父子进程通过管道进行通信，子进程通过管道写端向父进程传递在若干次请求访问完毕后记录到的总信息，父进程通过管道读端读取子进程发来的相关信息，子进程在测试时间完成后结束，父进程在所有子进程退出后统计并显示最后的测试结果，然后退出。webbench最多可以模拟3万多个并发连接数。 ==使用webbench== 首先下载webbench-1.5并安装； 进入webbenc... </summary> </entry> <entry><title>C++实现十大排序算法</title><link href="https://shenshenzhou.github.io/posts/Sort/" rel="alternate" type="text/html" title="C++实现十大排序算法" /><published>2022-07-25T17:11:12+08:00</published> <updated>2022-08-03T19:12:16+08:00</updated> <id>https://shenshenzhou.github.io/posts/Sort/</id> <content src="https://shenshenzhou.github.io/posts/Sort/" /> <author> <name>ShenshenZhou</name> </author> <category term="题解" /> <summary> 参考： 十大经典排序算法（C++实现 C++实现十大排序算法 n：元素个数。 k：桶的个数。 In-place：原地算法，不占用额外内存。 Out-place：非原地算法，占用额外内存。 稳定性：如果排序前后两个相等元素的相对位置不变，则认为是稳定的。 冒泡排序 从左到右，依次比较相邻的元素大小，更大（小）的元素交换到右边，这样所有元素比较完之后，最右边的元素一定是最大（小）的，重复此过程就可以完成所有元素的排序。 // 冒泡排序 void BubbleSort(vector&amp;lt;int&amp;gt;&amp;amp; vec) { int n = vec.size(); for (int i = 0; i &amp;lt; n - 1; ++i) { // 每轮排序都会确定一个最大的元素，所以下轮排序就减少一个元素，需要n-1轮排序 for (in... </summary> </entry> <entry><title>设计模式之观察者模式</title><link href="https://shenshenzhou.github.io/posts/Observer/" rel="alternate" type="text/html" title="设计模式之观察者模式" /><published>2022-07-23T16:07:57+08:00</published> <updated>2022-07-23T16:07:57+08:00</updated> <id>https://shenshenzhou.github.io/posts/Observer/</id> <content src="https://shenshenzhou.github.io/posts/Observer/" /> <author> <name>ShenshenZhou</name> </author> <category term="笔记" /> <category term="设计模式" /> <summary> 观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。又可以称作发布-订阅模式。 优缺点 有点： 降低了目标与观察者之间的耦合关系，符合依赖倒置原则。 目标与观察者之间建立了一套触发机制。 缺点： 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。 应用场景 应用于一个对象的行为改变可能会影响其它对象的行为改变的场景。比如EXCEL中改变数据，则对应的折线图、饼状图、柱状图等都要改变。 #include&amp;lt;iostream&amp;gt; #include&amp;lt;vector&amp;gt; #include&amp;lt;memory&amp;gt; using namespace std; // 观... </summary> </entry> <entry><title>设计模式之工厂模式</title><link href="https://shenshenzhou.github.io/posts/Factory/" rel="alternate" type="text/html" title="设计模式之工厂模式" /><published>2022-07-23T12:09:16+08:00</published> <updated>2022-07-23T12:09:16+08:00</updated> <id>https://shenshenzhou.github.io/posts/Factory/</id> <content src="https://shenshenzhou.github.io/posts/Factory/" /> <author> <name>ShenshenZhou</name> </author> <category term="笔记" /> <category term="设计模式" /> <summary> 简单工厂模式 就是创建一个工厂类，让工厂类去实例化产品对象。 优缺点 优点：可以降低代码的耦合度，当需要产品对象时，让工厂去生产，不必关心生产产品的具体细节，实现了创建与使用相分离。 缺点：扩展性差，需要改变工厂类的代码，违反开闭原则（对扩展开放，对修改关闭）。每增加一个产品都要添加一个具体的产品类，并且在工厂类中添加一个匹配项。 应用场景 对于产品种类相对较少的情况，可以考虑使用简单工厂模式。 #include&amp;lt;iostream&amp;gt; #include&amp;lt;string&amp;gt; using namespace std; // 产品接口（抽象） class Car { public: virtual void Show() = 0; }; // 具体的产品类1（实现） class MB : public Car { public: virtual... </summary> </entry> <entry><title>设计模式之单例模式</title><link href="https://shenshenzhou.github.io/posts/Singleton/" rel="alternate" type="text/html" title="设计模式之单例模式" /><published>2022-07-22T22:09:55+08:00</published> <updated>2022-07-22T22:09:55+08:00</updated> <id>https://shenshenzhou.github.io/posts/Singleton/</id> <content src="https://shenshenzhou.github.io/posts/Singleton/" /> <author> <name>ShenshenZhou</name> </author> <category term="笔记" /> <category term="设计模式" /> <summary> 什么是单例模式 单例模式就是一个类只能产生一个实例。 单例模式的特点 单例类只有一个实例对象 该单例对象必须由单例类自行创建； 单例类对外提供一个访问该单例的全局访问点 单例模式的优缺点： 优点： 可以设置全局访问点，优化和共享资源访问 可以避免对资源的多重占用 由于系统内存中只存在一个对象，所以可以节约系统资源，提高性能 缺点： 单例模式一般没有接口，扩展困难。 单例模式不利与代码测试。在调试过程中，如果单例中的代码没有执行完，不能模拟生成一个新的对象。 与单一职责原则有冲突。原因：一个类应该只实现一个逻辑，而不关心它是否是单例，是不是要单例取决于环境；单例模式把“要单例”和业务逻辑融合在一个类。 单例模式的使用场景 系统只需要一个实例对象，比如，配置信息类，如系统要求提供一个唯一的序列号生成器或资源管理器，... </summary> </entry> </feed>
