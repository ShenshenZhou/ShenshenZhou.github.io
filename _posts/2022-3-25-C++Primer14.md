---

title: C++Primer5 第14章 重载运算符和类型转换 
date: 2022-3-25 23:35:10 +0800
tags: [笔记,C++Primer5,C++]
categories: [笔记,C++]

---

**说明：**通过重载类间运算符完成类对象之间的类型转换。

### 基本概念

1、重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。

注意：如果是成员函数，因为this绑定到左侧运算对象，所以成员运算符的参数数量比运算对象的数量少一个。

2、对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数。

> 如果都是内置类型的话，运算符的含义无法改变，就无意义了。

3、选择作为成员函数或者非成员函数？

在某些时候别无选择，因为有的运算符必须作为成员；其它情况下，运算符作为普通函数比作为成员函数更好。

> 为什么更好？因为作为成员函数，它的左侧运算对象必须是运算符所属类的一个对象，左侧运算对象调用运算符函数完成运算。
>
> ```c++
> string s = "world";  // 如果operator+是成员函数的话
> string t = s + "!";  // 正确 s.operator+("!")
> string u = "hi" + s;  // 错误 "hi".operator+(s)
> ```

* 幅值=、下标[]、调动()、成员访问箭头->运算符必须是成员；
* 复合赋值运算符一般来说应该是成员，但并非必须；
* 改变对象运算状态或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员；
* 具有对称性的运算符可能转换任意一端的运算对象，如算术、相等性、关系和位运算符等，通常是非成员函数。

### 输入和输出运算符

#### 重载输出运算符<<

```c++
ostream &operator<<(ostream &os, const Sales_data &item{
    os << item.isbn << " " ;
    return os;
}
```

* 第一个形参是一个非常量ostream对象的引用，之所以是非常量，是因为向流写入内容会改变其状态，该形参是引用是因为我们无法直接赋值一个ostream对象。
* 第二个参数是常量引用，引用是因为我们希望避免复制实参，常量是因为打印对象不会改变对象的内容。
* 为了与其它输出运算符保持一致，operator<<返回它的ostream形参。

> 1、输出运算符因避免格式化操作，主要负责打印内容而非控制格式。
>
> 2、必须是非成员函数，否则，它的左侧运算对象是类的一个对象！

#### 重载输入运算符>>

```c++
istream &operator>>(istream &is, Salse_data &item) {
    double price;  // 不需要初始化 因为我们会读入它
    is >> items.bookNo >> item.units_sold >> price;
    // 输入检查！！！
    if (is) {
		items.revenue = item.units_sold * price;
    } else {
        item = Sales_data();  // 输入失败 对象被赋予默认状态
    }
    return is;
}
```

* 第一个参数是读取流的引用
* 第二个参数非常量，因为目的就是将数据读入这个对象中
* 返回某个给定流的引用

> 注意：必须处理输入可能失败的情况，重载输出运算符不用。
>
> 输入错误可能有类型错误或者读到文件末尾或其它错误。

### 算术和关系运算符

1、因左侧和右侧运算对象可以进行转换，一般为非成员函数。因不需要改变运算对象的状态，所以形参都是常量引用。

2、如果类定义了算术运算符，一般也会定义一个对应的符合赋值运算符，此时，最有效的方法就是使用复合赋值运算符来定义算术运算符。

> 为什么？因为算术运算符会把运算结果存到一个临时的局部变量中，再返回这个局部变量的副本，而是用复合赋值运算符则可避免该消耗。

### 赋值运算符

赋值运算符必须定义成成员函数，符合赋值运算符可以不是，但是还是倾向于把包括它在内的所有赋值运算符都定义在类的内部。

### 下标运算符

如果一个类包含下标运算符，通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。

> 为什么返回引用？因为这样下标可以出现在赋值运算符的任意一端。
>
> 为什么定义常量版本？因为如果下标运算符作用于一个常量对象时，需要返回常量引用以确保不会给返回的对象赋值。

```c++
class StrVec {
public:
    // 普通引用版本
    string &operator[](size_t n) {
		return elements[n];
    }
    // 常量成员且返回常量引用版本
    const string &operator[](size_t n) const {
        return elements[n];
    }
private:
    string *elements;  // 指向数组首元素的指针
};
```

### 递增和递减运算符

1、定义递增和递减运算符应该同时定义前置版本和后置版本，因为改变的是所操作对象的状态，所以应该被定义为类的成员。

2、定义前置递增、递减运算符：

* 为了和内置版本一致，应该返回递增或递减后对象的引用
* 工作机理都需要检查索引值是否有效，若无异常，则返回引用

```c++
StrBlobPtr& StrBlobPtr::operator++() {
    // 如果curr已经指向了容器的尾后位置 无法递增
    check(curr, "increment past end of StrBlobPtr");
    ++curr;
    return *this;
};
StrBlobPtr& StrBlobPtr::operator--() {
    --curr;
    // 如果curr是0 无法递减
    check(curr, "decrement past begin of StrBlobPtr");
    return *this;
};
```

3、区分前置、后置运算符：

为了解决这个问题，后置版本接受一个额外的（不被使用的）int类型的形参。当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参。一般我们不适用这个额外的形参，它的唯一作用就是区分前置和后置版本，而不是参与运算。不用它，所以无需命名。

为了与内置类型保持一致，后置运算符返回对象原值而非引用。

后置运算符用各自的前置版本来完成，且无需检查有效性。

```c++
class StrBlobPtr {
public:
    StrBlobPtr operator++(int);
    StrBlobPtr operator--(int);
};
```

### 成员访问运算符

### 函数调用运算符

1、类定义了调用运算符，则该类的对象称为函数对象。

```c++
struct AbsInt {
    int operator()(int val) const {
		return val < 0 ? -val : val;
    }
};
int i = -42;
AbsInt obj;
int absi = obj(i);  // 将i传给obj.operator() 即调用成员函数
```

2、lambda是函数对象





