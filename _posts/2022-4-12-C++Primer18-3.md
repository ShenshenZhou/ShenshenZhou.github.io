---

title: C++Primer5 多重继承和虚继承
date: 2022-4-12 17:27:31 +0800
tags: [笔记,C++Primer5,C++]
categories: [笔记,C++]

---

### 多重继承

多重继承是指从多个直接基类中产生派生类的能力。

派生类的派生列表可以包含多个基类，每个基类包含一个可选的访问说明符。

```c++
class Bear : public ZooAnimal { };
class Panda : public Bear, public Endangered { };
```

#### 多重继承的派生类从每个基类中继承状态

多重继承中，派生类的对象包含有每个基类的子对象。

#### 派生类构造函数初始化所有基类

构造一个派生类的对象将同时构造并初始化它的所有基类子对象，派生类的构造函数初始值列表将实参分别传递给每个直接基类，其中**基类的构造顺序与派生列表中的出现顺序一致**，而与派生类的构造函数初始值列表中的顺序无关。

* ZooAnimal是最终直接基类，首先初始化
* 接下来初始化第一个直接基类Bear
* 然后初始化第二个直接基类Endangered
* 最后初始化Panda

#### 继承的构造函数与多重继承

C++11新标准允许派生类从它的多个基类中继承构造函数，但是如果继承了相同的构造函数，程序将产生错误，因此派生类必须为该构造函数定义自己的版本。

#### 析构函数与多重继承

和往常一样，派生类的析构函数只负责清楚派生类本身分配的资源，派生类的成员及基类都是自动销毁的，析构顺序与构造顺序相反。

#### 多重继承的派生类的拷贝和移动操作

与只有一个基类的继承一样，如果派生类定义了自己拷贝控制成员，则必须在完成的对象上进行操作。只有当派生类使用的是合成的拷贝控制成员时，才会自动对基类部分执行这些操作，每个基类分别使用自己的对应成员隐式的完成拷贝控制。

### 类型转换与多个基类

在多重继承中，我们可以令某个可访问基类的指针或引用直接指向一个派生类对象。编译器不会在派生类向基类的几种转换中进行比较和选择，因为在它看来转换到任意一个基类都一样好。

注意：因为认为一样好，所以要小心二义性错误。

```c++
void print(const Bear&);
void print(const Endangered&);
Panda ying_yang("ying_yang");
print(ying_yang);  // 二义性错误 哪个基类？需要带前缀限定符避免二义性
```

#### 基于指针类型和引用类型的查找

与只有一个基类的继承一样，对象、指针和引用的静态类型决定了我们能够使用哪些成员。

### 多重继承下的类作用域

对于一个派生类来说，从它的几个基类中分别继承名字相同的成员是完全合法的，但是在使用这个名字是必须明确指出它的版本，否则会产生二义性错误。

> 如果想避免二义性，最好的办法就是在派生类中定义一个新版本。

### 虚继承

为什么要有虚继承？

因为在默认情况下，派生类含有继承链上每个类对应的子部分，如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象。

虚继承的目的就是令某个类做出声明，承诺愿意共享它的基类，其中，共享的基类子对象称为虚基类。在这种机制下，不管虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。

虚继承有一个特性：必须在虚派生的真实需求出现前就已经完成虚派生的操作。

> 虚派生只影响从指定了的虚基类的派生类中进一步派生出的类，它不会影响派生类本身。（想象一下菱形继承关系）

#### 使用虚基类

```c++
class Raccoon : public virtual ZooAnimal { };
class Bear : virtual public ZooAnimal { };
// Panda中只有一个ZooAnimal实例
class Panda : public Bear, public Raccoon,
			  public Endangered { };  
```

1、通过在派生列表中添加关键字`virtual`来指定虚基类，virtual说明符表明了一个愿望，即在后续的派生类当中共享虚基类的同一份实例。

> 与访问说明符的顺序随意。

2、如果某个类指定了虚基类，则该类的派生仍按常规方式进行。

#### 支持向基类的常规类型转换

无论基类是不是虚基类，派生类对象都能被可访问基类的指针或引用操作。

#### 虚基类成员的可见性

因为每个共享的虚基类只有一个共享的子对象，所以该基类的成员可以被直接访问，并且不会产生二义性。但是如果成员被多于一个基类覆盖（多个多重继承），则一般情况下派生类必须为该成员自定义一个新的版本。

### 构造函数与虚继承

在虚派生中，虚基类是由最底层的派生类初始化的。但每个类都可能称为最底层的派生类，所以只要我们能创建虚基类的派生类对象，该派生类的构造函数就必须初始化它的虚基类。

> 如果以普通规则处理初始化任务，虚基类将会在多条继承路径上别重复初始化。

```c++
// 如果Bear位于派生的最底层
Bear::Bear(string name, bool oe) : 
		ZooAnimal(name, oe, "Bear") { }  // 初始化虚基类
// Panda最底层
Panda::Panda(string name, booe oe) :
		ZooAnimal(name, oe, "Panda"),
		Bear(name, oe),
		Raccoon(name, oe),
		Endangered(Endangered::critical) { }  //初始化虚基类
```

#### 虚继承的对象的构造方式

含有虚基类的对象的构造顺序与一般的构造顺序稍有区别：首先使用提供给最底层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的顺序依次对其进行初始化。

* 首先使用Panda的构造函数初始值列表中提供的初始值构造虚基类ZooAnimal部分
* 接下来构造Bear部分
* 然后构造Raccoon部分
* 然后构造Endangered部分
* 最后构造Panda部分

如果Panda没有显示初始化ZooAnimal基类，则其默认构造函数将被调用，如果没有默认构造函数，代码将发生错误。

#### 构造函数与析构函数的次序

一个类可以有多个虚基类，此时，这些虚的子对象按照它们在派生列表中出现的顺序从左向右一次构造。

```c++
class Character { };
class BookCharacter : public Character { };
class ToyAnimal { };
class TeddyBear : public BookCharacter,
				  public Bear,
				  public virtual ToyAnimal { };
```

编译器按照直接基类的声明顺序对其一次进行检查，以确定其中是否含有虚基类，如果有，则先构造虚基类，然后按照声明的顺序逐一构造其它非虚基类。

```c++
ZooAnimal();		// Bear的虚基类
ToyAnimal();		// 直接虚基类
Character();		// 第一个间接非虚基类
BookCharacter();	// 第一个直接非虚基类
Bear();				// 第二个直接非虚基类
TeddyBear();		// 最底层的派生类
```



