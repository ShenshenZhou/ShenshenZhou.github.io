---
title: C++Primer5 第4章 运算符
date: 2021-12-22 17:16:13 +0800
tags: [笔记,C++Primer5,C++]
categories: [笔记,C++Primer5]
---

**说明：**本章主要介绍由语言本身定义、用于内置类型运算对象的运算符，以及简要介绍几种标准库定义的运算符。

### 基础

1、左值和右值？

> 这个好像比较混乱，目前的理解就是左值是一个有名称、占据内存空间的变量，而右值是一个临时对象，使用一次就销毁，不能被程序的其它部分访问。但是右值引用可以使临时变量拥有名称，使程序的其它部分得以访问，并且该临时变量变成了左值。后续遇到问题再深究吧，这里书上讲的不太清楚！

2、求值顺序：

> 优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么方式求值。在大多数情况下，不会明确指定求值的顺序。
>
> 有四种运算符明确规定了运算对象的求值顺序：与`&&`、或`||`、条件`?:`、逗号`，`。

```c++
int i = f1() * f2();  // 我们知道f1和f2一定会在*之前被调用，但是我们无法知道二者的调用顺序，即先调用f1还是先调用f2完全由编译器决定。
```

### 算术运算符

1、整数相除结果还是整数，如果商含有小数，直接弃除。

2、取余运算的运算对象必须是整数类型。

> 在C++中如果是负数取模：A/B=A-A/B*B，其只（A/B）要去尾取整。

### 逻辑和关系运算符

1、短路求值：当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值，比如逻辑与和逻辑或。

2、进行比较时，如果比较对象不是布尔类型，不要使用true和false进行比较，会转换1和0。

### 赋值运算符

1、赋值运算符的左侧运算对象必须是一个可修改的左值。（字面值、算数表达式等右值不行）

2、赋值运算符的优先级低于比较运算符，条件语句中要加上括号。

3、复合赋值运算符只求值一次，普通运算符求值两次：一次作为右边表达式的一部分求值，另一次是作为赋值运算符的左侧运算对象求值。

### 递增和递减运算符

1、除非必须，否则不适用后置版本的递增和递减运算符。

* 前置版本简单，把值+1后直接返回改变后的值。
* 后置版本为了返回为修改前的值，需要将原始值存储下来，效率较低。

2、如果既使对象+1或-1又要使用它原来的值，就是用后置版本。

### 成员访问运算符

1、解引用运算符的优先级低于点运算符。

```c++
*p.size();  // 错误 p是指针 没有size成员 要变成(*p).size() 简化为p->size()
```

2、箭头运算符作用于指针类型的运算对象，结果是一个左值。点运算符，如果成员所属的对象是左/右值，结果就相应是左/右值。

### 条件运算符

可以嵌套，但是不要超过两层，否则代码可读性急剧下降。

### 位运算符

建议仅将位运算符用于处理无符号类型，因为符号位如何处理没有明确的规定。

### sizeof运算符

1、sizeof返回一条表达式或一个类型名字所占的字节数。

```c++
sizeof(type);
sizeof expr;  // 返回的是表达式结果类型的大小 但是sizeof并不实际计算运算对象的值
```

2、执行sizeof会得到整个数组的大小，所以可以巧妙得到数组的元素个数。

```c++
sizeof(a)/sizeof(*a);
```

### 逗号运算符

逗号运算符含有两个对象，按照从左到右的顺序依次求值。

### 类型转换

算数类型隐式转换。

数组转换为指针。

常量整数值0和字面值nullptr可以转换成空指针。

指针的算数类型0和nullptr可以转换为布尔类型false。

**显示转换（强制类型转换）:**

> 虽然有时不得不转换，但是这种方法本质上是危险的，尽量不用。

`static_cast`：任何具有明确定义的类型装换，只要不包含底层const，都可以使用。

```c++
int j;
double slope = static_cast<double>(j) / i;
```

`const_cast`：只改变运算对象的底层const，注意只改变const属性，其它类型转换不行。

```c++
const char *pc;
char *p = const_cast<char*> pc;
const_cast<string>(pc);  // 错误 只改变const属性
```

`dynamic_cast`：用于类继承层次间的指针或引用转换，主要用于安全地向下转型，即基类对象的指针或引用转换为同一继承层次下的其它指针或引用。

> 至于向上转型（即派生类指针或引用类型转换为其基类类型），其本身就是安全的，普通的转换（隐式转换）已经能够达到目的，尽管可以使用dynamic_cast，但是没有必要，毕竟使用强制类型转换也是需要开销的。

`reinterpret_cast`：不太明白，但是比较危险，遇到再说！

注意：旧式的强制类型转换不那么清晰明了，容易被看漏，一旦转换出现问题，追踪起来也很困难。

```c++
type (expr);  // 函数形式的强制类型转换
(type) expr;  // C语言风格的强制类型转换
```

