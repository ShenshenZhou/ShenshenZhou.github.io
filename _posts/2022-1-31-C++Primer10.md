---

title: C++Primer5 第10章 泛型算法
date: 2022-1-31 17:55:17 +0800
tags: [笔记,C++Primer5,C++]
categories: [笔记,C++Primer5]

---

**说明：**本章主要讲述泛型算法和迭代器的更多细节。标准库并未给每个容器添加大量功能，而是提供了一组泛型算法，这些算法中的大多数都独立于任何特定的容器。

### 概述

1、大多数算法都是定义在`algorithm`头文件中，`numeric`中定义的有一组数值泛型算法。

2、一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。

3、迭代器令算法不依赖于容器，但是算法依赖于容器元素类型的操作。

> 比如find算法用元素类型的==运算符与给定元素值比较，有些元素还要求元素类型支持<运算符。

4、算法永远不会执行容器的操作！！！

> 算法可能修改容器的值，在容器内移动元素，但永远不会直接添加或删除元素，也不会改变底层容器的大小。

### 初始泛型算法

理解算法的一个基本方法就是了解它们是否读取元素、改变元素或是重排元素。

#### 只读算法

##### find

```c++
// find返回第一个指向给定值元素的迭代器 没找到就返回end
auto result = find(vec.begin(), vec.end(), val);  // 迭代器范围+要寻找的值
```

##### count

```c++
// 返回容器内某个元素出现的次数
int num = count(vec.begin(), vec.end(), val);  // 迭代器范围+查找的元素
```

##### accumulate

```c++
// 定义在numeric头文件中 容器求和算法
// 第三个参数决定了函数中使用哪个加法运算符以及 返回值的类型！
int sum = accumulate(vec.begin, vec.end(), 0);  // 迭代器范围+和的初值
string sum = accumulate(v.begin(), v.end(), string(""));  // 连接元素到string上
string sum = accumulate(v.begin(), v.end(), "");  // 错误 const char*无+运算符
```

##### equal

```c++
// 确定两个序列是否保存相同的值 
// 使用单一迭代器表示第二个序列的算法 都假设第二个序列至少与第一个序列一样长
equal(v1.begin(), v1.end(), v2.begin());  // 迭代器范围+第二个容器的首迭代器
```

#### 写容器元素算法

##### fill

```c++
// fill将给定的值赋予输入序列中的每个元素
fill(vec.begin(), vec.end(), val);  // 迭代器范围+给定值
vector<int> v;
fill_n(v.begin(), 10, 0);  // 向指定位置添加10个0 错误！！！因为容器为空 语句未定义
```

##### back_inserter

插入迭代器是一种向容器中添加元素的迭代器，不如back_insert，定义在头文件`iterator`中。

> back_intserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。

```c++
vector<int> v;
fill_n(back_inserter(v), 10, 0);  // 正确 每次赋值都会在v上调用push_back
```

##### copy

拷贝算法将输入范围中的元素拷贝到目的序列中。

> 传递考别的目的序列至少要包含与输入序列一样多的元素。

```c++
int a1[] = { 0, 1, 2, 3, 4 };
int a2[sizeof(a1)/sizeof(*a1)];  // a2和a1一样大
// copy返回的是目的位置迭代器的值（递增后） 即a2的尾后迭代器
auto ret = copy(begin(a1), end(a1), a2);  // 把a1的内容拷贝给a2
```

##### replace

replace算法读入一个序列，并将其中所有等于给定值的元素改为另一个值。

```c++
replace(lst.begin(), lst.end(), 0, 42);  // 迭代器范围+指定值+修改后的值
// 如果希望保留原序列不变 需要备份
replace_copy(lst.begin(), lst.end(), back_insert(vec), 0, 42);
// 调用后lst未改变 vec包含lst的一个拷贝 原来在lst中值为0的元素在vec中变为42
```

#### 重排容器元素的算法

##### sort

##### unique

unique重排容器的元素，将不重复的元素出现在容器的开始部分，返回的迭代器指向最后一个不重复元素之后的位置（即第一个有重复的元素），此位置之后的元素仍存在，但我们不知道它们的值。

```c++
sort(word.begin(), word.end());  // 字典序排序
auto end_unique = unique(word.begin, word.end());  // 指向不重复区域后一个位置迭代器
word.erase(end_unique, word.end());  // 使用容器成员删除重复单词
```

### 定制操作

标准库允许我们使用自己定义的操作来代替默认运算符。

#### 谓词

谓词是一个可调用的表达式，返回结果是一个能用作条件的值（即返回布尔值的函数）。一元谓词只接受单一参数，二元谓词接受两个参数。

##### stable_sort

```c++
sort(word.begin(), word.end());  // 按照字典序排序
stable_sort(word.begin(), word.end(), isShorter);  // 在字典序排序的基础上按照长度排序
```

#### lambda表达式

##### lambda介绍

1、我们可以向一个算法传递任何类型的可调用对象。

> 对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它是可调用的。

2、目前使用过的可调用对象有哪些？

* 函数
* 函数指针
* 重载了函数调用运算符的类
* lambda表达式

3、lambda表达式形式：

一个lambda表达式表示一个可调用的代码单元，可以理解为一个未命名的内联函数。

```c++
[捕获列表](参数列表) -> 返回类型 { 函数体 }
```

lambda和函数的异同？

* 调用方式相同，都使用调用运算符()
* 与函数不同，lambda可能定义在函数内部
* 与函数不同，lambda必须使用位置返回类型，即->
* lambda可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体
* 与函数不同，lambda不能由默认参数

##### 向lambda传递参数

与普通函数类似，实参初始化形参，但是不能有默认实参。

##### 使用捕获列表

lambda通过将函数内部的局部对象包含在捕获列表中来指出将会使用这些变量。

> 先捕获，后使用！
>
> 捕获列表只用于局部非static对象，lambda可以直接使用局部static对象和函数之外声明的名字。

##### 调用find_if

find_if用来查找第一个具有特定大小的元素，对输入序列中的每个元素调用给定的这个谓词（实质上就是一个函数），它返回第一个使谓词返回非0值的元素，如果不存在，返回尾后迭代器。

```c++
find_if(word.begin(), word.end(), 谓词);  // 迭代器范围+查找条件（谓词）
auto wc = find_if(word.begin(), word.end(),
                 [sz](const string& a)
                  	{ return a.size() >= sz; });  // 返回第一个不小于sz的string
```

##### for_each算法

接受一个可调用对象，并对输入序列中每个元素调用此对象。

```c++
for_each(wc, word.end(),
        [](const string& s){ cout << s << ""; });
```

#### lambda捕获和返回

##### 值捕获

与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝。

##### 引用捕获

当以引用捕获一个变量时，必须保证在lambda执行时变量时存在的。

##### 隐式捕获

除了显示列出我们希望使用的变量之外，还可以让编译器根据lambda体中的代码来推断我们要使用哪些变量。应在捕获列表中写一个&或=，=表示采用值捕获方式，&表示采用引用捕获方式。

如果希望对一部分变量采用值捕获，其它变量采用引用捕获，可以混合使用隐式捕获和显示捕获，但捕获的第一个元素必须是&或者=。

```c++
for_each(word.begin(), word.end(),
        [&, c](const string& s){ os << s << c; });  // os引用捕获 c显示捕获
```

##### 可变lambda

默认情况下，值捕获变量不会被改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在菜蔬列表尾加上关键字`mutable`。

```c++
void fcn(){
    int val = 42;  // 局部变量
    auto f = [val] () mutable { return ++val; };
    val = 0;
    auto j = f();  // j = 43  
    // 创建时拷贝 而不是调用时拷贝!!!
}
```

##### 指定lambda返回类型

当需要为lambda定义返回类型时，必须使用尾置返回类型。默认情况下，lambda有return之外的语句，则编译器假定次lambda返回void。

```c++
transform(v.begin(), v.end(), v.begin(),
         [](int i) -> int  // 尾置返回类型
          { if(i < 0) return -i ;
          	else reutrn i; });
```

#### 参数绑定

何时用lambda，何时用函数？

* 只在一两个地方使用的简单操作，可用lambda
* 需要在很多地方使用的操作，通常应该定义一个函数
* 如果一个操作需要很多语句，通常使用函数更好
* 如果捕获列表为空，用函数代替很简单，但是捕获局部变量的lambda，用函数替换并不容易

##### 标准库bind函数

bind定义在头文件`functional`中，可将其看做一个通用的函数适配器。

```c++
// 当我们调用newfunction时 newfunction会调用function 并传递给它arg_list的参数
auto newfunction = bind(function, arg_list);
```

##### bind的参数

```c++
auto g = bind(f, a, b, _2, c, _1);
// 新调用对象g会调用f
// g会将arg_list传递给f 也就是a, b, _2, c, _1
// _n是占位符 表示g的第n个参数
// g将自己的第2个参数作为f的第三个参数传递给f 第一个参数作为f的第五个参数传递给f
```

##### 利用bind重排参数顺序

```c++
// 利用bind颠倒函数的参数顺序
sort(word.begin(), word.end(), isShorter);  // 由短到长排序
sort(word.begin(), word.end(), bind(isShorter, _2, _1));  //  由长到短排序
```

### 再探迭代器

除了容器定义的迭代器外，标准库在头文件`iterator`中还定义了额外几种迭代器。

* 插入迭代器：迭代器绑定到容器上，可用来向容器插入元素
* 流迭代器：绑定到输入输出流上，可以遍历关联的IO流
* 反向迭代器：由后向前移动
* 移动迭代器：不拷贝元素，而是移动元素

### 泛型算法结构

* 五类迭代器
* 算法形参结构
* 算法命名规范

### 特定容器算法

list和forward_list定义了特有的成员函数形式的算法，其性能要比通用版本好的多。

> 对于链表，优先使用成员函数版本算法。