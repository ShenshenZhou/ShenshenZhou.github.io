---

title: C++Primer5 第8章 IO库
date: 2022-1-15 21:21:27 +0800
tags: [笔记,C++Primer5,C++]
categories: [笔记,C++]

---

**说明：**本章介绍IO库的基本内容(IO类，文件输入输出，string流)。第14章介绍如何编写自己的输入输出运算符；第17章介绍如何控制输出格式以及如何对文件进行随机访问。

### IO类

1、标准库定义了常用的IO类型：

* `iostream`定义了用于读写流的基本类型。
* `fstream`定义了读写命名文件的类型。
* `sstream`定义了读写内存string对象的类型。

类fstream和stringstream都是继承自类iostream，输入类都继承自istream，输出类都继承自ostream。

2、概念上，设备类型和字符大小都不会影响我们要执行的IO操作，标准库使我们能忽略这些类型不同的流之前的差异，这是通过继承机制实现的。我们通常可以将一个派生类当做基类对象来使用。

> 我们可以用>>读取数据，而不用管是从一个控制台窗口，一个磁盘文件，还是一个string读取。也不用管读取的字符能是存入一个char对象内，还是需要一个wchar_t对象来存储。

#### IO对象无拷贝和赋值

> 不能拷贝对象，也就无法把函数的返回类型和形参设置为流类型。
>
> 进行IO操作的函数以**引用方式**传递和返回流，读写一个IO操作会改变其状态，因此不能是const的。

#### 条件状态

1、IO操作一个与生俱来的问题就是可能发生错误。一个流一旦发生错误，其上后续的IO操作都将失败。确定一个流状态的最简单的方法是将它当作一个条件来使用：

```c++
while (cin >> word)
    // 输入操作成功 流保持有效状态，则条件为真。
    // ok:读操作成功 进行后续操作...
```

2、管理条件状态：

* 使用`good`和`fail`是确定流的总体状态的方法。

* 流对象的`rdstate`成员返回一个`iostate`值，对应流的当前状态。
* `setstate`操作将给定条件位置位，表示发生了对应错误。
* 不接受参数的`clear`版本清除所有错误标志，执行clear后，调用good会返回true。

```c++
auto old_state = cin.rdstate();  // 记住cin的当前状态
cin.clear();  // 清除cin所有错误标志 使cin有效
process_input(cin);  // 使用cin
cin.setstate(old_state);  // 将cin改为原有的状态
```

#### 管理输出缓冲

1、每个输出流都管理一个缓冲区，用来保存程序读写的操作。

> 有了缓冲制，操作系统就可以将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作很耗时，所以上述操作可以带来很大的性能提升。

```c++
cout << "please enter a vlur: ";  // 可能立即打印出来 也可能被OS保存到缓冲区中随后打印
```

2、导致缓冲区刷新的原因：

* 程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行；
* 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区；
* 可以使用操纵符endl等来显示刷新缓冲区；
* 在每个输出操作之后，可以使用操纵符unitbuf设置流的内部状态，来清空缓冲区；
* 一个输出流可能被关联到另一个流，当读写被关联的流时，关联到的流的缓冲区会被刷新。

```c++
cout << "hi" << endl;  // 输出hi和一个换行 然后刷新缓冲区
cout << "hi" << flush;  // 输出hi 然后刷新缓冲区
cout << "hi" << ends;  // 输出hi和一个空字符 然后刷新缓冲区
cout << unitbuf;  // 所有输出操作后都立即刷新缓冲区
	// 任何输出都立即刷新 无缓冲
cout << nounitbuf;  // 回到正常的缓冲方式
```

3、如果程序崩溃，输出缓冲区不会被刷新

> 当调试一个已经崩溃的程序时，需要确认你认为已经输出的数据确实已经刷新了。否则，可能要花费很多时间追踪代码为什么没有执行上，而实际上代码已经执行了，只是程序崩溃后缓冲区没有刷新，输出数据被挂起没有打印而已。

4、当一个输入流被关联到一个输出流时，任何试图从输入读取数据的操作都会先刷新关联的输出流。标准库将cout和cin关联在一起，因此：

```c++
cin >> val;  // 导致cout的缓冲区被刷新
```

### 文件输入输出

1、fstream除了继承自iostream类型的行为之外，还有一些新的成员：

```c++
fstream fstrm;  // 创建一个未绑定的文件流
fstream fstrm(s);  // 创建一个fstream 并打开名为s的文件
fstream fstrm(s, mod);  // 同上 但按照指定mod打开文件
fstrm.open(s);  // 打开名为s的文件 并与fstrm绑定
fstrm.close(s);  // 关闭绑定的文件
fstrm.is_open();  // 返回bool 指出相关联的文件是否成功打开且尚未关闭
```

2、文件模式：

```c++
in;  // 以读方式打开
out;  // 以写方式打开
app;  // 每次写操作前都定位到文件末尾
ate;  // 打开文件后立即定位到文件末尾
trunc;  // 截断文件
binary;  // 以二进制方式进行IO
```

* 只有对ofstream或fstream设定out模式。
* 只有对ifstream或fstream设定in模式。
* 只有当out也被设定时才可设定trunc模式。
* 只要trunc模式没被设定，就可以设定app模式。
* 默认情况下，即使没有指定trunc，以out模式打开的文件也会被截断。
* ate和binary模式可用于任何类型的文件流对象，且可以和其它任何文件模式组合使用。

> 以out模式打开文件会丢弃已有数据，因此，保留ofstream打开的文件中已有数据的唯一方法是显示指定app或in模式。
>
> 每次调用open时会确定文件模式，因此，每次打开文件，都要设定模式。

```c++
ofstream out("file1");  // 隐含的以输出模式打开并截断文件
ofstream out("file2", ofstream::out | ofstream::app);  // 显示指定app保存文件内容
```

### string流





**注意：**

本章没有例题，真正的读写文件还是得编代码去实践！！！

做了课后习题去尝试着对文件进行简单的操作。

