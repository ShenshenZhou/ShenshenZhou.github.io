---
title: C++Primer6 第6章 函数
date: 2022-1-3 22:13:44 +0800
tags: [笔记,C++Primer5,C++]
categories: [笔记,C++Primer5]
---

**说明：**本章讲述函数的定义和声明、函数传参、返回类型、重载函数、函数匹配以及函数指针。

### 函数基础

1、函数的定义包括一下部分：返回类型、函数名字、0个或多个形参组成的列表或函数体。

2、函数的调用完成两项工作：一是实参初始化函数对应的形参；二是将控制权转移给被调用函数，此时，主调函数的执行被暂时中断，被调函数开始执行。

3、遇到return语句时函数结束执行过程。也是完成两项工作，一是返回return语句中的值，如果有的话；二是将控制权从被调函数移回主调函数。

4、实参的类型必须和形参类型一致（但是可以执行隐式类型转换），就想初始值的类型必须和初始化对象的类型匹配一样。

5、函数的形参列表可以为空，但不能省略，形参用逗号分隔，每个形参都是含有一个声明符的声明，即时两个形参的类型一样，也必须把两个类型都写出来。

6、在C++中，名字有作用域，对象有生存周期。形参和函数体内定义的变量为局部变量，局部变量仅在函数的作用域可见，同时还会隐藏外层作用域中同名的其他所有声明。在所有函数体之外定义的对象在程序启动时被创建，直到程序结束时才会销毁。

7、有些时候，有必要令全局变量的生命周期贯穿在函数调用及之后的时间，可以定义为`static`类型。局部静态变量在程序执行路径第一次经过对象定义语句时初始化，直到程序终止才被销毁，在此期间对象所在的函数结束执行也不会对它有影响。

```c++
int count_calls() {
	static int ctr = 0;
	return ++ctr;
}

int main() {
	for (int i = 0; i != 10; ++i) {
		// 如果不是static类型 输出全是1 因为每次调用函数都会初始化变量ctr
		// statci类型的话 再次调用函数时 ctr已经存在了 并且是前一次函数返回的值 
		cout << count_calls() << endl;  
	}

	return 0;
}
```

8、与变量类似，函数应该在头文件中声明而在源文件中定义。这样可以确保同一函数的所有声明保持一致，而且想要改变函数借口，只需改变一条声明语句即可。

### 参数传递

和其他变量一样，形参的类型决定了形参和实参的交互方式。如果形参是引用类型，它将绑定到对应的实参上，否则，将实参的值拷贝后赋给形参，即引用传递和值传递。

#### 值传递

初始值会拷贝给一个变量，对变量的改动不会影响初始值。

#### 引用传递

尽量使用引用传递，如果无需改变引用形参的值，最好将其声明为常量引用。

#### const形参和实参

当用实参初始化形参时会忽略掉顶层const，换句话说：当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。

我们可以使用非常量初始化一个底层const对象，但是反过来不行。

把函数不会改变的形参定义为普通引用是一个比较常见的错误：

* 误导调用者，使人感觉函数可以修改它的实参的值。
* 非常量引用会极大的限制函数所能接受的实参类型，如上所述，我们不能用const对象、字面值或者需要类型转换的对象传递给普通的引用形参。
* 还有一个难以察觉的问题，假设其它参数将他们的形参定义为常量引用，那么上述find_char就无法在此类函数中正常使用。

```c++
// 上述第二点
int find_char(string& s, char c, int& occurs);  // 不良设计 应为const string&
find_char("Hello world", 'o', ctr);  // 错误 字面值常量不能传给普通引用变量

// 上述第三点
bool is_sentence(const string& s){
    int ctr = 0;
    // 下面错误 因为s是常量引用 而find_char被定义为只接受普通引用
    return find_char(s, '.', ctr) == s.size() - 1 && ctr == 1;  
}
```

**所以要尽量使用常量引用**

#### 数组形参

1、尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式，如果我们给print函数传递一个数组，实参自动的转换为指向数组首元素的指针，数组的大小对函数的调用没有影响。

```c++
void print(const int*);  // 三种方式一样 形参都是int*类型
void print(const int[]);
void print(const int[10]);
```

2、C++允许将变量定义为数组的引用，类似的，形参也可以是数组的引用。

```c++
void print(int (&arr)[10]){  // 必须带括号 数组从数组名由内像外阅读
    for (auto elem : arr)
        cout << elem << endl;
}
```

#### 含有可变形参的函数

有时我们无法提前预知应该向函数传递几个实参。为了编写处理不同数量实参的函数，**C++11**提供了两种方法：如果所有的实参类型相同，可以传递一个名为`initializer_list`的标准库类型；如果实参的类型不同，可以编写一种特殊的函数，也就是可变参数模板（16.4节）。

`initializer_list`：函数实参数量未知但全部实参类型相同，是标准库类型，定义在同名头文件中。

与vector一样，initializer_list是一种模板类，但是其对象中的元素永远是常量值，我们无法改变。

```c++
void error_msg(initializer_list<string> i1){
    // 有begin和end成员 可以范围for语句处理 
    for (auto beg = i1.begin(); beg != i1.end(); ++beg)
        cout << *beg << " ";
    cout << endl;
}
```

如果想向initializer_list形参中传递一个值的序列，必须把序列放在一对花括号内。

```c++
// 下面是两个string对象 第一次调用传入三个值 第二次传入两个值
if (expected != actual)
    error_msg({ "functionX", expected, actual });
else
    error_msg({ "functionX", "ok" });
```

省略符形参：为了便于让C++程序访问某些特殊的C代码设置的，应该仅仅用于C和C++通用的类型，应该注意的是：大多数类类型的对象在传递给省略符形参时都无法正确拷贝。

```c++
void foo(parm_list, ...);  // 对应于部分指定形参的实参是执行类型检查
void foo(...);  // 省略符形参所对应的实参无需类型检查。
```

### 返回类型和return语句

return语句终止当前正在执行的函数并将控制权返回到调动该函数的地方。

#### 无返回值函数

1、返回void的函数不要求非得有return语句，因为在这类函数最后一句后面会隐式地执行return。

2、void函数如果想在中间位置提前退出，可以使用return语句。

3、返回值为void的函数可以使用return expression的形式，但是该语句必须是另一个返回void的函数，强行返回其它类型的表达式会产生错误。

#### 有返回值函数

1、只要函数的返回类型不是void，则该函数内的每条return语句必须返回一个值。return语句的返回值的类型必须与函数的返回类型相同，或者能隐式的转换成函数返回类型。

2、在含有return语句的循环后面，应该也有一天return语句，如果没有的话程序会出错！！！

3、返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。

4、如果函数返回引用，则该引用仅是它所引对象的一个别名。

```c++
// 无论是调用函数还是返回结果都不会真正拷贝string对象 而只是它的一个别名
const string& shorterString(const string& s1, const string& s2){
    return s1.size() <= s2.size() ? s1 : s2;
}
```

5、**不要返回局部对象的引用或指针**

> 函数完成后，它所占用的存储空间也随之被释放掉，因此，返回一个局部对象的引用或指针，会使引用和指针指向一个不存在的对象！

```c++
const string& manip(){
	string ret;
    if (!ret.empty())
        return ret;  // 错误 返回局部对象的引用
    else
        return "empty";  // 错误 返回一个局部临时量
}
```

6、调用运算符的优先级与点运算符和箭头运算符相同，并且符合左结合率。因此，如果函数返回指针、引用、类的对象，我们能使用函数调用的结果访问结果对象的成员。

```c++
auto sz=shorterString(s1,s2).size();  // 返回对象是string 所以可以调用size()
```

7、调用一个返回引用的函数得到左值，其它返回类型得到右值。可以像使用其它左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是**非常量引用**的函数的结果幅值。

```c++
char& getVal(string &str, size_t ix){
	return str[ix];
}
int main(){
	string s{"a value"};
    cout << s << endl;
    getVal(s,0) = 'A';  // 将s[0]的值改为A
    cout << s << endl;
}
```

8、函数可以返回花括号包围的值。**C++11**

> 类似于其它返回结果，可以用用此列表来初始化表示函数返回的临时对象。
>
> 如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间不应该大于目标类型的空间。如果函数返回的是类类型，由类本身定义初始值如何使用。

#### 返回数组指针

因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。

1、使用类型别名

```c++
typedef int arr[10];  // arr是一个类型别名 表示的类型为含有十个整数的数字
using arr = int[10];  // 同上 C++11
arr* func(int i);  // func返回一个指向arr数组的指针
```

2、声明一个返回数组指针的函数

数组的维度必须跟在函数名字后面，且形参列表应该由于数组的维度。

```c++
int (*func(int i))[10];  // func返回一个指针 指针指向整型数组 必须带小括号
```

3、使用尾置返回类型 **C++11**

尾置返回类型跟在形参列表后面并以一个->符号开头，为了表示真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto。

```c++
auto func(int i) -> int (*)[10];  // 返回一个指针 该指针指向整型数组
```

4、会用decltype

如果我们已经知道函数返回的指针将指向哪个数组，就可以使用decltype声明返回类型。

```c++
int odd = { 1, 3, 5, 7, 9 };
int even = { 2, 4, 6, 8, 10 };
decltype(odd) *arrptr(int i){
    return (i % 2) ? &odd : &even;  // 返回一个指向数组的指针 既然是指针 别忘了&
}
```

### 函数重载

1、函数名字相同且形参列表不同，称为函数重载。函数名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以在一定程度上减轻起名字、记名字的负担。

2、重载函数应该在形参数量或形参类型上有所不同。

3、重载和const形参

* 顶层const不影响函数的对象，一个有顶层const的形参无法和另一个没有顶层const的形参区分。
* 如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的从const是底层的。因为底层const不能转换为其它类型，只能将const对象传递给const形参。虽然非常量可以转换为const，但是编译器会优先选用非常量版本的函数，所以可以区分。

```c++
Record lookup(phone);
Record lookup(const phone);  // 重复声明函数 形参类型并不能区分
Record lookup(Account&);  // 函数作用于引用
Record lookup(const Account&);  // 函数作用于常量引用 底层const
```

4、函数匹配是一个过程，在这个过程中可以把函数调用与一组重载函数的某个函数关联起来。

5、调用函数重载时有三种可能的结果

* 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。
* 找不到任何一个函数与调用的实参匹配，发出无匹配的错误信息。
* 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择，将发生错误。称为二义性调用。

6、通常来说，不应该在局部作用域内声明函数，因为在内层作用域内声明名字，它将隐藏外层作用域中声明的同名实体（同名变量也可以隐藏函数），在不同作用域中无法重载函数名。

> C++中，名字查找发生在类型检查之间。也就是说一旦名字发生重复，内层将隐藏外层。

### 特殊用途语言特性

#### 默认实参

1、可以为形参提供默认实参，但是一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。

2、函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。

```c++
string screen(size_t hz = 24, size_t wid=80, char backgrnd = ' ');  // 函数声明
string window;
window = screen();  // 等于调用screen(24,80,' ')
window = screen(66);  // 等于调动screen(66,80,' ')
window = screen(66,256);  // 等于调用screen(66,256,' ') 
```

3、函数可以多次声明，但是在给定的作用域内，一个形参只能被赋予一次默认实参。

4、局部变量不能作为默认实参。

```c++
size_t wd;
char def = ' ';
size_t ht();
string screen(size_t = ht(), size_t = wd, char = def);
string window = screen;
void f2(){
    def = '*';  // 改变默认实参的值
    size_t wd = 100;  // 隐藏了外层定义的wd 但是没有改变默认值
    window = screen();  // 相当于调用screen(ht(), 80, '*')
}
```

#### 内联函数

将函数指定为内联函数，通常就是将它在每个调用点处内联的展开。可以减少函数运行时的开销。

> 内联只是向编译器的一个请求，编译器可以选择忽略，就是内联不内联，编译器说的算。

```c++
cout << shorterString(s1, s2) << endl;
cout << (s1.size() < s2.size() ? s1 : s2) << endl;  // 调用处内联展开
```

#### constexpr函数

1、字面值属于常量表达式，用字面值初始化的const对象也是常量表达式(非const对象不是)。

2、constexptr函数的返回类型及所有形参的类型都得是字面值类型，而且函数体重必须有且只有一条return语句，但是它并一定返回查常量表达式。

### 函数匹配

1、确定候选函数

* 候选函数与被调用的函数同名
* 候选函数声明在函数调用点可见

2、从候选函数中选出可行函数

* 可行函数形参数量与本次调用提供的实参数量相等
* 每个实参的类型与对应的形参类型相同，或者能转换成形参的类型

3、寻找最佳匹配

逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。

有且只有一个函数满足以下条件，则匹配成功：

* 该函数每个实参的匹配都不劣于其它可行函数需要的匹配
* 至少有一个实参的匹配由于其它可行函数提供的匹配

```c++
void f(int, int);
void f(double double = 3.14);
f(42, 2.56);  // 二义性调用 报错
```

### 函数指针

1、函数指针指向的是函数而非对象，和其他指针一样，函数指针指向某种特定类型，函数的类型由它的形参类型和返回类型共同决定，与函数名无关。声明一个指向该函数的指针，只需要用指针替换函数名即可，注意指针加上()！

```c++
bool lengthCompare(const string &, const string &);
bool (const string &, const string &);  // 上述函数类型
vool (*pf)(const string &, const string &);  // pf指向一个函数
```

2、当我们把函数名作为一个值使用时，该函数自动地转换成指针。还能使用指向函数的指针调用该函数，无需提前解引用指针。

```c++
pf = lengthCompare();  // pf指向该函数
pf = &lengthCompare();  // 等价
bool b1 = pf("hello", "goodbye");  // 调用函数
bool b2 = (*pf)("hello", "goodbye");  // 等价调用
```

3、指向不同函数类型的指针间不存在转换规则（即类型不能隐式转换，需要精确匹配），但是我们可以为函数指针赋一个nullptr或者值为0的整型常量表达式。

4、形参可以是指向函数的指针，此时形参看起来是函数类型，实际上却是当成指针使用，我们可以直接把函数当做实参使用，此时它会自动转换为指针。

```c++
bool useBigger(const string& s1, const string& s2m, bool (*pf)(const string&, const string&));  // 将形参定义成指向函数的指针
useBigger(s1, s2, lengthCompare); // 自动将函数转换为指向该函数的指针
```

5、和数组一样，decltype返回函数类型，不会将函数类型自动转换成指针类型。

```c++
decltype(sumLength) *getFcn(const string &); // 牢记加上指针！！！
```

6、和数组类似，虽然不能返回一个函数，但是可以返回一个指向函数的指针，最好使用类型别名。

