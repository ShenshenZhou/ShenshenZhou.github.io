---
title: 第九届蓝桥杯真题题解
date: 2022-4-6 21:35:20 +0800
tags: [蓝桥杯,题解,算法]
categories: [题解,蓝桥杯]
---

研究生组是从第十届开始设立的，所以前面的只有大学ABC组。

#### 分数

```c++
#include<iostream>

using namespace std;

// 求最大公约数
int gcd(int a, int b) {
	return b ? gcd(b, a % b) : a;
}

int main() {
	// 求几项和找规律 1/1 3/2 7/4 15/8 
	// 或者用等比数列算出来 然后约分
	int a = 1, b = 1;
	for (int i = 1; i < 20; ++i) {
		a = 2 * a + 1;
		b *= 2;
	}

	int t = gcd(a, b);
	cout << a / t << '/' << b / t;
	return 0;
}
```

#### 星期一

```c++
#include<iostream>

using namespace std;

int month[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31 };

// 判断是不是闰年
bool Check(int a) {
	if (a % 400 == 0 || (a % 4 == 0 && a % 100 != 0))
		return true;
	else
		return false;
}

int main() {
	// 2000.12.31为星期日
	int yearday = 0;  // 一年的天数
	for (int i = 1; i < 13; ++i) {
		yearday += month[i];
	}

	int count = 0;  // 闰年的个数
	for (int i = 1901; i <= 2001; ++i) {
		if (Check(i)) {
			++count;
		}
	}

	int sumday = count * (yearday + 1) + (2001 - 1901 - count) * yearday;
	int week = sumday / 7;  // 多少个周
	int mod = sumday % 7; // 多几天
	if (mod == 1)
		--week;  // 如果刚好多一天 因为从2001.1.1开始 所以减去这个星期一

	cout << week;
	return 0;
}
```

#### 乘积尾零

> 2*5产生0，分解成2和5取最小的就行了。注意技巧，不可能直接乘的！

```c++
#include<iostream>

using namespace std;

int arr[10][10] = {
	5650, 4542, 3554, 473, 946, 4114, 3871, 9073, 90, 4329,
	2758, 7949, 6113, 5659, 5245, 7432, 3051, 4434, 6704, 3594,
	9937, 1173, 6866, 3397, 4759, 7557, 3070, 2287, 1453, 9899,
	1486, 5722, 3135, 1170, 4014, 5510, 5120, 729, 2880, 9019,
	2049, 698, 4582, 4346, 4427, 646, 9742, 7340, 1230, 7683,
	5693, 7015, 6887, 7381, 4172, 4341, 2909, 2027, 7355, 5649,
	6701, 6645, 1671, 5978, 2704, 9926, 295, 3125, 3878, 6785,
	2066, 4247, 4800, 1578, 6652, 4616, 1113, 6205, 3264, 2915,
	3966, 5291, 2904, 1285, 2193, 1428, 2265, 8730, 9436, 7074,
	689, 5510, 8243, 6114, 337, 4096, 8199, 7313, 3685, 211
};

int main() {
	int num2 = 0, num5 = 0;
	long long sum = 1;
	for (int i = 0; i < 10; ++i) {
		for (int j = 0; j < 10; ++j) {
			while (true) {
				if (arr[i][j] % 2 == 0){
					++num2;
					arr[i][j] /= 2;
				}
				else if (arr[i][j] % 5 == 0) {
					++num5;
					arr[i][j] /= 5;
				}
				else {
					break;
				}
			}
			
		}
	}

	cout << min(num2,num5);
	return 0;
}
```

#### [第几个幸运数](https://blog.csdn.net/weixin_46239370/article/details/105483056)

> 参考了上面的链接，为啥直接循环不对呢，思维好像有点问题。

```c++
#include<iostream>
#include<queue>
#include<unordered_set>

using namespace std;

typedef long long ll;
int w[3] = { 3,5,7 };
ll ans = 59084709587505;

// 优先队列解法
int main() {
	unordered_set<ll> s;
	priority_queue <ll, vector<ll>, greater<ll>> q;
	q.push(1);

	int cnt = 0;
	while (q.size()) {
		++cnt;
		ll t = q.top();  // 取最大值 即优先队列首元素
		q.pop();

		if (t == ans) {
			cout << cnt - 1 << endl;
			break;
		}

		// 3 5 7 第二轮 3*3 3*5 3*7 按照顺序加入优先队列中
		for (int i = 0; i < 3; ++i) {
			ll x = t * w[i];
			if (!s.count(x)) {
				// 如果s中x的个数为0
				q.push(x);
				s.insert(x);
			}
		}

	}

	return 0;
}


// 暴力搜索
#include<stdio.h>
int main()
{
    int c = 0;
    long long n, j, i, r;
    scanf_s("%lld", &n);
    for (i = 1; i <= n; i = 3 * i)
    {
        for (j = 1; i * j <= n; j = 5 * j)
        {
            for (r = 1; i * j * r <= n; r = 7 * r)
                ++c;
        }
    }
    printf("%d", c - 1);
    return 0;
}
```

#### 航班时间

> 字符串处理！如何消除时差？

```c++
#include<iostream>

using namespace std;

typedef long long ll;
int t;

// 计算飞行时间函数
ll FlyTime() {
	// 读入两个基本时间
	int h1, m1, s1, h2, m2, s2;
	scanf_s("%d:%d:%d %d:%d:%d", &h1, &m1, &s1, &h2, &m2, &s2);
	char x;  // 读取后缀字符
	int ans = 0;  // 记录隔了几天到
	while ((x = getchar()) != '\n') {
		if (x <= '9' && x >= '0')
			ans = x - '0';
	}

	// 计算起止时间的差值
	ll num1 = h1 * 3600 + m1 * 60 + s1;
	ll num2 = h2 * 3600 + m2 * 60 + s2 + ans * 24 * 3600;
	return num2 - num1;
}


int main() {
	cin >> t;
	while (t--) {
		// 计算两次的差值求平均 就可以消除时差的影响
		ll res1 = FlyTime();
		ll res2 = FlyTime();
		ll res = (res1 + res2) >> 1;
		// 输出时间
		printf("%02d:%02d:%02d\n", res / 3600, res % 3600 / 60, res % 60);
	}

	return 0;
}
```

#### [三体攻击](https://blog.dotcpp.com/a/83736)

> 三维前缀和和三维查分？真就是数学杯？

#### [全球变暖](https://blog.csdn.net/qq_63047764/article/details/123310657)

> dfs，dfs，dfs！

```c++
#include<iostream>

using namespace std;

int n;  // 输入
const int num = 1005;
bool vis[num][num];  // 标记该点是否被检查过
int ans[num] = { 0 };  // 记录每个连通块有几块陆地不被淹没 初始为0
char mp[num][num];  // 存图
int land = 0;  // 连通块数量
int flood = 0;  // 沉没的连通块数量

// dfs 
void dfs(int a, int b, int k) {
	if (mp[a][b] == '.') return;
	if (vis[a][b]) return;

	if (mp[a + 1][b] == '#' && mp[a - 1][b] == '#'
		&& mp[a][b + 1] == '#' && mp[a][b - 1] == '#')
		++ans[k];  // 不被淹没的陆地数量
	vis[a][b] = 1;  // 标记已经找过该点
	// 寻找附近点
	dfs(a + 1, b, k);
	dfs(a - 1, b, k);
	dfs(a, b + 1, k);
	dfs(a, b - 1, k);
}

int main() {
	// 输入
	cin >> n;
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			cin >> mp[i][j];
		}
	}

	// 遍历所有点 遇到陆地搜索
	for (int i = 0; i < n; ++i) {
		for (int j = 0; j < n; ++j) {
			// 找到陆地就dfs该岛屿 如果所有陆地都被淹没 被淹没的岛屿数加1
			if (mp[i][j] == '#' && !vis[i][j]) {
				dfs(i, j, land);
				++land;
			}
		}
	}

	// 如果被淹没的岛屿内没有不被淹没的陆地 沉没的岛屿数+1
	for (int i = 0; i < land; ++i) {
		if (ans[i] == 0)
			++flood;  // ans[i]表示第i块岛屿上不被淹没的陆地数量
	}
	
	cout << flood << endl;
	return 0;
}
```

