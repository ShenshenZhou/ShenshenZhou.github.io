---
title: 第十一届蓝桥杯真题题解
date: 2022-3-27 22:46:25 +0800
tags: [蓝桥杯,题解,算法]
categories: [题解,蓝桥杯]
---

### 研究生组：

#### 试题A：约数个数

> 暴力搜索。

```c++
#include<iostream>

using namespace std;

int main() {
	int n;
	cin >> n;

	int count = 0;
	for (int i = 1; i <= n; ++i) {
		if (n % i == 0) {
			++count;
		}
	}

	cout << count;
	return 0;
}
```

#### 试题B：寻找2020

> [读文件](https://zhuanlan.zhihu.com/p/352961501)，然后暴力搜索。

```c++
#include<iostream>
#include<fstream>

using namespace std;

char text[500][500];

void ReadText() {//将文本内容复制到数组text中
	// 流对象 要有头文件
	ifstream fin;

	// 打开文件 检查是能够打开
	fin.open("2020.txt", ios::in);
	if (!fin.is_open()) {
		cout << "can not open the file!" << endl;
	}

	// 以行读取
	int line = 0;
	while (fin.getline(text[line], sizeof(text[line]))) {
		++line;
	}

	// 关闭文件
	fin.close();
}
int main()
{
	int i, j = 0, count = 0;
	ReadText();

	//求每行的2020
	for (i = 0; i < 500; i++)
		for (j = 0; j < 500; j++)
			if (text[i][j + 3] != NULL) {
				if (text[i][j] == '2' && text[i][j + 1] == '0' && text[i][j + 2] == '2' && text[i][j + 3] == '0') {
					count++;
					j = j + 1;
				}
			}
			else {
				break;
			}

	//求每列的2020
	for (j = 0; j < 500; j++)
		for (i = 0; i < 500; i++)
			if (text[i + 3][j] != NULL) {
				if (text[i][j] == '2' && text[i + 1][j] == '0' && text[i + 2][j] == '2' && text[i + 3][j] == '0') {
					count++;
					i = i + 1;
				}
			}
			else {
				break;
			}

	//求对角线的2020
	for (i = 0; i < 500; i++)
		for (j = 0; j < 500; j++)
			if (text[i + 3][j + 3] != NULL) {
				if (text[i][j] == '2' && text[i + 1][j + 1] == '0' && text[i + 2][j + 2] == '2' && text[i + 3][j + 3] == '0')
					count++;
			}
			else {
				break;
			}

	cout << count;
	return 0;
}
```

#### 试题C：平面分割

> 找规律，不要乱找，控制变量按照顺序一个个来，大问题分成小问题，然后举简单例子递推，暴力搜索，[可参考这个](https://juejin.cn/post/7063802996458520607)。

```c++
#include<iostream>

using namespace std;

int main() {
	// 递推找规律 f(i)=f(i-1)+i 也就是当前分割的平面数=上次分割的平面数+当前的所有直线数
	// 可以这样想：0条直线为1个平面 以后每多i条直线就累加i个平面
	int count = 1;
	for (int i = 1; i <= 20; ++i) {
		count += i;
	}

	// 直线的规律好找 但是如果直线和圆混在一起可能就有点慌乱了
	// 可以在直线的基础上添加圆 然后找规律
	// 两线一圆8个平面 两线两圆14个平面 两线三圆22个平面
	// 一个圆可以与直线、圆各有两个交点 所以每加一个圆 加的平面数=2*加之前的所有直线和圆的个数
	for (int i = 1; i <= 20; ++i) {
		count += 2 * (20 + i - 1);  // i = 1时 只有一个圆 只能与直线相交
	}

	cout << count;
	return 0;
}
```

#### 试题D：蛇形填数

> 找规律，矩阵的下标有一定的关系，然后算出来就行了。[其它解法](https://blog.csdn.net/weixin_46239370/article/details/115044476)

```c++
#include<iostream>

using namespace std;

int main() {
	// 要求的数字时主对角线上的数字
	// 如果在第i行 那么就是第2*i-1个斜行 第i个斜行有i个数字 而主对角线上的数字恰好是中间那个
	// 所以累加1~(2i-1-1) 然后加上(2i-1)/2+1个数字就行了

	int num = 0;
	for (int i = 1; i <= 2 * 20 - 1 - 1; ++i) {
		num += i;
	}

	num += (2 * 20 - 1) / 2 + 1;
	cout << num;
	return 0;
}
```

#### [试题E：七段码](https://blog.csdn.net/qq_45530271/article/details/109189978)

> dfs搜索，[并查集](https://blog.csdn.net/the_zed/article/details/105126583)判断。

#### 试题F：成绩分析

> 虽然写的很烂，但还是要坚持用STL。

```c++
#include<iostream>
#include<vector>
#include<algorithm>

using namespace std;

int main() {
	int n;  // 考试人数
	cin >> n;

	vector<int> score;
	for (int i = 0; i < n; ++i) {
		int m;
		cin >> m;
		score.push_back(m);
	}

	sort(score.begin(), score.end());
	double sum = 0;
	for (int i = 0; i < n; ++i) {
		sum += score[i];
	}

	printf("%d\n", score[n - 1]);
	printf("%d\n", score[0]);
	printf("%.2f\n", sum / n);
	return 0;
}
```

#### [试题G：回文日期](https://blog.csdn.net/m0_54069398/article/details/114075231)

> 虽然没有什么特别难的算法，但是一道综合题，基础牢固思路清晰才能更快地写出来！

```c++
#include<iostream>
#include<string>
#include<vector>

using namespace std;

const int s = 1000, e = 8999;  // 范围
vector<int> arr;  // 存储满足条件的整数
int month[13] = { 0,31,28,31,30,31,30,31,30,30,31,30,31 };

// 判断是否满足日期格式
bool Check(int yy, int mm, int dd) {
	// 满足条件是月份在1-12 日期小于当月的最大日期 要判断是否为闰年
	if (mm > 1 && mm <= 12) {
		if (yy % 400 || (yy % 4 && yy % 100 != 0))
			month[2] = 29;  // 判断是够是闰年

		if (month[mm] >= dd) 
			return true;
		else 
			return false;
	}
	return false;
}

// 预处理回文日期
void Preprocess() {
	for (int i = s; i <= e; ++i) {
		string s = to_string(i);  // 转为string

		// 0123 3210 满足回文格式
		for (int j = 3; j >= 0; --j) {
			s += s[j];
		}

		int mm = (s[4] - '0') * 10 + (s[5] - '0');  // 月 
		int dd = (s[6] - '0') * 10 + (s[7] - '0');  // 日

		if (Check(i, mm, dd)) {
			// 如果满足格式要求 存起来 注意转换成int
			int k = stoi(s);  // 转int
			arr.push_back(k);  // 统一存起来
		}

		month[2] = 28;  // 这里是重置month[2] 因为前面可能是闰年 把month[2]改成29了
	}
}

// 找到第一个比输入大的回文日期
int UpperBound(int key) {
	// 二分查找
	int l = 0, r = arr.size();
	while (l < r) {
		int mid = (l + r) >> 1;
		if (arr[mid] > key)
			r = mid - 1;
		else
			l = mid + 1;
	}

	return l;
}


// 寻找满足条件ababbaba格式的回文日期
int ababbaba(int index) {
	for (int i = index; i < arr.size(); ++i) {
		string s = to_string(arr[i]);  // 直接转换成字符串可以逐位比较

		// 1212这样格式的才能满足ababbaaba
		if (s[0] == s[2] && s[1] == s[3])
			return i;
	}

	return 0;
}

int main() {
	int n;
	cin >> n;
	Preprocess(); // 预处理找到满足格式的回文日期

	int index = UpperBound(n);  // 找到大于n的回文日期
	cout << arr[index] << endl; 

	index = ababbaba(index);  // 找到满足题目条件的回文日期
	cout << arr[index];

	return 0;
}

```

